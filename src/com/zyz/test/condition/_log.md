
##### ConditionTest

###### 1. 只有三个线程写入数据

多个线程 执行同一个 BoundedBuffer 对象的 put() 方法 :

一个线程执行 `lock.lock()` 方法拿到锁后, 如果 buffer 满了, 那么执行 `notFull.await()` 会释放锁, 导致其他线程也可以
调用 `lock.lock()` 方法再次拿到锁, 所以日志 

```java
//INFO - 18, 准备写入--3
//INFO - 16, 准备写入--3
//INFO - 17, 准备写入--2
//INFO - 18, 已写入--3
//INFO - 16, 已写入--3
//INFO - 17, 已写入--2
//
//INFO - 17, 缓存满了, 等待...        //此时线程 17 执行 notFull.await() 释放锁
//INFO - 16, 准备写入--6
//INFO - 16, 缓存满了, 等待...        //线程 16 拿到了锁, 由于缓存满了, 所以也会执行 notFull.await() 释放锁
//INFO - 18, 准备写入--9
//INFO - 18, 缓存满了, 等待...        //线程 18 拿到了锁, 由于缓存满了, 所以也会执行 notFull.await() 释放锁
```

###### 2. 三个线程写入数据 + 主线程取出一条数据后 通知一个线程

主线程在 BoundedBuffer 对象的 take() 方法中取出数据后, 调用 `notFull.signal()` 通知某一个线程写入数据。

```java
//INFO - 17, 准备写入--6
//INFO - 16, 准备写入--9
//INFO - 18, 准备写入--9
//INFO - 17, 已写入--6
//INFO - 16, 已写入--9
//INFO - 18, 已写入--9
//...
//INFO - 16, 准备写入--5
//INFO - 16, 缓存满了, 等待...
//INFO - 17, 准备写入--8
//INFO - 17, 缓存满了, 等待...
//INFO - 18, 准备写入--0
//INFO - 18, 缓存满了, 等待...
//...

//INFO - 1, 取出了一条数据 --------5   //主线程取出后调用 notFull.signal() 只唤醒了其中一个线程 INFO - 18
//INFO - 18, 已写入--0                //线程 18 之前就准备写入 0
//INFO - 1---主线程得到了数据--5
//INFO - 18, 准备写入--8              //因为 Runnable 中是 while 循环, 不断的写入, 所以马上轮到 线程 18
//INFO - 18, 缓存满了, 等待...
```

###### 3. 三个线程写入数据 + 主线程取出一条数据后 通知多个线程

主线程在 BoundedBuffer 对象的 take() 方法中取出数据后, 调用 `notFull.signalAll()` 通知所有其他线程写入数据。

```java
//INFO - 18, 准备写入--6
//INFO - 17, 准备写入--5
//INFO - 16, 准备写入--7
//...
//INFO - 18, 准备写入--5
//INFO - 18, 缓存满了, 等待...
//INFO - 17, 准备写入--1
//INFO - 16, 准备写入--4
//INFO - 17, 缓存满了, 等待...
//INFO - 16, 缓存满了, 等待...
//
//INFO - 1, 取出了一条数据 --------6
//INFO - 18, 已写入--5
//
//INFO - 17, 缓存满了, 等待...
//INFO - 1---主线程得到了数据--6
//INFO - 16, 缓存满了, 等待...
//
//INFO - 18, 准备写入--0
//INFO - 18, 缓存满了, 等待...
```